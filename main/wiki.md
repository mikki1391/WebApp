### Frontend и Backend-разработка
Фронтенд (англ. frontend) — это разработка пользовательских функций и интерфейса. К ним относится всё, что пользователи видят на сайте или в приложении, и с чем можно взаимодействовать: картинки, выпадающие списки, меню, анимация, карточки товаров, кнопки, чекбоксы, интерактивные элементы. На любой странице в интернете виден результат работы фронтенд-разработчика.

Бэкенд (англ. backend) — это логика работы сайта, скрытая от пользователя. Именно там происходит то, что можно назвать работой сайта.

Чтобы понять, в чём разница между backend и frontend, возьмём пример:

● Визуальное отображение карточки товара и кнопка «заказать» — это фронтенд.

● Обновление цены и остатков товара на складе, добавление товара в корзину при нажатии кнопки, функция сравнения двух товаров — это бэкенд.

● Результат, который видит пользователь: цена и остатки товара, товар в корзине, сравнение — это снова фронтенд.

Код бэкенда увидеть невозможно — он не отправляется пользователю напрямую в смартфон или браузер, а работает на сервере, на котором хранится приложение или сайт. Сервер — это специальный мощный компьютер, который подключён к интернету и служит для хранения данных, работы кода и его отправки в браузер.

Чаще всего термины фронтенд и бэкенд используют, когда говорят о веб-разработке: создании сайтов, мобильных приложений и сервисов. При создании программ для ПК или сложных инструментов для аналитики, финансовых технологий или машинного обучения «фронтенд» не нужен и остаётся только «бэкенд» — но его так не называют, потому что он немного отличается от бэкенда в веб-разработке.


### Создание серверной части веб-приложения на PHP:

Создание шаблонов PHP - это метод, используемый для отделения логики представления (HTML, CSS и JavaScript) от логики обработки на стороне сервера (PHP-код) в веб-приложении. Такой подход способствует четкому разделению задач, облегчая поддержку и понимание кода. Шаблоны обычно представляют собой HTML-файлы, содержащие заполнители для динамического содержимого, которые заменяются фактическими данными при визуализации шаблона.

В приведенном коде есть примеры создания шаблонов PHP в виде отдельных файлов для верхнего и нижнего колонтитулов и отдельных страниц. Вот несколько примеров:

1. templates/header.php : Этот файл содержит общую HTML-структуру для начальной части каждой страницы, включая открывающие элементы <!DOCTYPE>, <html> и <head>, а также меню навигации. Файл заголовка включается в другие файлы подкачки с помощью инструкции require_once.

```php
<!DOCTYPE html>
<html lang="en">
<head>
    <!-- ... -->
</head>
<body>
    <header>
        <nav>
            <!-- ... -->
        </nav>
    </header>
```

2. templates/footer.php : Этот файл содержит общую HTML-структуру для конечной части каждой страницы, такую как закрывающие элементы </body> и </html>. Он также включает в себя код для отображения имени вошедшего в систему пользователя, как было запрошено ранее. Файл нижнего колонтитула включается в другие файлы подкачки с помощью инструкции require_once.
```php
    <footer>
        <!-- ... -->
    </footer>
    <?php if (isset($_SESSION['username'])): ?>
        <div class="logged-in-user">
            <?php echo htmlspecialchars($_SESSION['username']); ?>
        </div>
    <?php endif; ?>
</body>
</html>
```

3. Отдельные файлы, такие как index.php , register.php , login.php , post_ad.php , и ads.php служат шаблонами для их соответствующих страниц. Они содержат основное содержимое, специфичное для каждой страницы, и включают файлы верхнего и нижнего колонтитулов для единообразного оформления всего сайта.

```php
<?php
// index.php
require_once 'templates/header.php';
?>

<main>
    <!-- ... -->
</main>

<?php require_once 'templates/footer.php'; ?>
```

С помощью шаблонов PHP логика представления отделена от логики обработки на стороне сервера, что упрощает поддержку и понимание кода.

#### получение данных из форм

Вот пример получения данных из регистрационной формы в register.php (не из этого проекта)

```php
<!-- register.php -->
<?php
require_once 'templates/header.php';
?>

<main>
    <h1>Register</h1>
    <form action="register_user.php" method="post">
        <label for="username">Username:</label>
        <input type="text" id="username" name="username" required>
        <br>
        <label for="password">Password:</label>
        <input type="password" id="password" name="password" required>
        <br>
        <input type="submit" value="Register">
    </form>
</main>

<?php require_once 'templates/footer.php'; ?>
```

В этом примере регистрационная форма содержит два поля для ввода: одно для имени пользователя и другое для пароля. Атрибуту действия формы присвоено значение register_user.php , который является файлом, который будет обрабатывать обработку данных формы. Для атрибута метода формы установлено значение post, что означает, что данные формы будут отправляться как часть тела HTTP-запроса, а не как часть URL-адреса.

```php
<?php
// register_user.php
require_once 'includes/db.php';
require_once 'includes/functions.php';

// Check if the form was submitted using the POST method
if ($_SERVER['REQUEST_METHOD'] == 'POST') {
    // Get the form data from the $_POST superglobal array
    $username = $_POST['username'];
    $password = $_POST['password'];

    // Do something with the form data, like saving it to the database
    $user_id = register_user($username, $password);

    // Redirect the user to the appropriate page based on the registration result
    if ($user_id) {
        header('Location: login.php?registration_success=true');
    } else {
        header('Location: register.php?registration_error=true');
    }
} else {
    // If the form was not submitted using POST, redirect back to the registration page
    header('Location: register.php');
}
```

В этом файле данные формы извлекаются из суперглобального массива $_POST. Затем значения имени пользователя и пароля передаются функции register_user() для сохранения пользовательских данных в базе данных. После обработки данных формы пользователь перенаправляется либо на страницу входа в систему (если регистрация прошла успешно), либо обратно на страницу регистрации (если произошла ошибка).

#### взаимодействие с базой данных


#### сессии.


### Асинхронная отправка данных.

Асинхронная отправка данных - это процесс передачи данных между клиентом (например, веб-браузером) и сервером без блокирования выполнения других задач и ожидания ответа пользователем. В веб-приложениях это обычно достигается с помощью JavaScript и AJAX (Asynchronous JavaScript and XML) для отправки и получения данных в фоновом режиме без необходимости перезагрузки страницы.

В приведенном коде есть пример асинхронной отправки данных с помощью функции fetch(), современного метода JavaScript для выполнения HTTP-запросов:

```javascript

// Отправляем данные формы в файл create_ad.php с помощью AJAX
fetch("create_ad.php", {
    метод: "POST",
    body: formData
})
.then(response => response.json())
.then(data => {
    if (data.success) {
        // Если объявление было создано успешно, обновите таблицу с новым объявлением
        const adRow = `
            <tr>
                <td>${data.ad.title}</td>
                <td>${data.ad.description}</td>
                <td>${data.ad.username}</td>
            </tr>
        `;
        document.querySelector(".ads-table tbody").insertAdjacentHTML("afterbegin", adRow);
    } else {
        // Если произошла ошибка, выведите сообщение об ошибке
        alert(data.error);
    }
});
```

В этом фрагменте кода функция fetch() отправляет асинхронный POST-запрос в файл create_ad.php с данными формы в качестве полезной нагрузки. Функция возвращает Promise, который разрешается в объект Response, представляющий ответ на запрос.

Часть .then(response => response.json()) обрабатывает ответ и преобразует его в объект JavaScript. Следующий блок .then() обрабатывает данные, полученные от сервера. Если объявление было создано успешно, таблица обновляется новым объявлением. Если произошла ошибка, в оповещении отображается сообщение об ошибке.

Такая асинхронная отправка данных позволяет пользователю продолжать взаимодействовать со страницей во время обработки запроса, что улучшает пользовательский опыт и позволяет обновлять содержимое страницы в режиме реального времени, не требуя полного обновления страницы.


### REST - архитектура.
REST (Representational State Transfer) - это архитектурный стиль, используемый для проектирования сетевых приложений. Он определяет набор ограничений и принципов, которые обеспечивают последовательный подход к созданию веб-сервисов. Основная идея REST заключается в том, чтобы рассматривать ресурсы (объекты данных) как URL-адреса, к которым можно получить доступ и манипулировать ими с помощью стандартных методов HTTP, таких как GET, POST, PUT и DELETE.

Основные характеристики архитектуры REST включают:

    1. Нестационарность: Каждый запрос от клиента к серверу должен содержать всю информацию, необходимую для понимания и обработки запроса. Сервер не должен хранить никакой информации о состоянии клиента между запросами.
    2. Клиент-сервер: Клиент и сервер - это отдельные сущности, которые общаются по сети. Клиент отвечает за пользовательский интерфейс, а сервер управляет ресурсами и данными.
    3. Кэшируемый: Ответы от сервера могут кэшироваться клиентом, что повышает производительность и снижает нагрузку на сервер.
    4. Многослойная система: Архитектура может быть разделена на несколько уровней, каждый из которых обеспечивает определенный набор функциональных возможностей. Такое разделение задач делает систему более модульной и удобной для обслуживания.

В данном сайте нет прямого примера архитектуры RESTful. Однако AJAX-запрос к файлу create_ad.php является примером взаимодействия клиент-сервер, что является одной из характеристик REST.

Чтобы сделать код более RESTful, можно создать специальную конечную точку API для управления объявлениями, следуя соглашениям RESTful дизайна. Например, могут быть следующие конечные точки:

    * GET /api/ads: Получение списка объявлений
    * POST /api/ads: Создать новое объявление
    * PUT /api/ads/:id: Обновить существующее объявление
    * DELETE /api/ads/:id: Удалить объявление

Код нужно будет переработать, чтобы использовать эти конечные точки API и следовать принципам RESTful. Например, AJAX-запрос в ads.php будет отправлять POST-запрос на /api/ads для создания нового объявления, а сервер будет обрабатывать запрос в безэталонном режиме.